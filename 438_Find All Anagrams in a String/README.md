**思路：** 最开始能想到的思路就是O(nm)，虽然效率不高，但是磕磕绊绊（在位置计算和map上优化了一下）也算能够A掉。参考了题解，发现题解采用的是一种移动窗口的
处理思路，按照题目的描述，字符串p应该就像一个筐子装着这些字母一样，不考虑顺序。那么设置两个筐子，一个为p，一个为s。在s中，按照p.length()的大小，移走一个
放进一个。每次就比较两个筐子是否相等，这样的话是O(n)的时间复杂度。这里要注意的一点是筐子的比较，是重载的vector的==，以前没遇到过，但是比较起来确实也很方
便。==的定义为：“两个容器具有相同的长度而且所有元素都相等，那么这两个容器就相等；否则，它们就不相等”。
