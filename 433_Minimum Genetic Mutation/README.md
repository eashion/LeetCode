这道题目之前做过很类似的，BFS可以A掉。但是从效率来看不是特别好，虽然做了一定的优化。参考讨论里面的解法，是设置了两个集合，一个起始状态集，一个终止状态集。
每次变化的也是单个字母，这样变化一次增加一个步数，因为变化出的字符串都是dict里面的，所以当两个集合出现交集的时候就可以输出步数。这个比BFS效率高的一种情况
可以思考，从A方式经过3步可以得到end字符串，但是使用BFS需要把所有的2步变化和1步变化都找一遍，所以优先队列在这里其实并没有起到很大的作用。与BFS的区别在于，
变化的步长每次都是1，变化后的结果可控。
